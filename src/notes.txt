#include <avr/io.h>
#include <util/delay.h>
#include <stdio.h>
#include <string.h>

// -----------------------------------------
// UART CONFIGURATION (for debugging)
// -----------------------------------------
#define F_CPU 16000000UL
#define BAUD 9600
#define MYUBRR (F_CPU/16/BAUD-1)

void uart_init(void) {
    UBRR0H = (unsigned char)(MYUBRR >> 8);
    UBRR0L = (unsigned char)(MYUBRR);
    UCSR0B = (1 << TXEN0);
    UCSR0C = (1 << UCSZ01) | (1 << UCSZ00);
}

void uart_tx(char data) {
    while (!(UCSR0A & (1 << UDRE0)));
    UDR0 = data;
}

void uart_print(const char *s) {
    while (*s) uart_tx(*s++);
}

void uart_print_int(int16_t val) {
    char buf[10];
    sprintf(buf, "%d", val);
    uart_print(buf);
}

// -----------------------------------------
// ADC CONFIGURATION
// -----------------------------------------
void adc_init(void) {
    ADMUX = (1 << REFS0); // AVcc reference
    ADCSRA = (1 << ADEN) | (1 << ADPS2) | (1 << ADPS1); // Enable, prescaler = 64
}

uint16_t adc_read(uint8_t channel) {
    ADMUX = (ADMUX & 0xF0) | (channel & 0x0F);
    ADCSRA |= (1 << ADSC);
    while (ADCSRA & (1 << ADSC));
    return ADC;
}

// -----------------------------------------
// SPI CONFIGURATION
// -----------------------------------------
#define CE_HIGH()  (PORTB |= (1 << PB1))
#define CE_LOW()   (PORTB &= ~(1 << PB1))
#define CSN_HIGH() (PORTB |= (1 << PB0))
#define CSN_LOW()  (PORTB &= ~(1 << PB0))

void spi_init(void) {
    DDRB |= (1 << PB3) | (1 << PB5) | (1 << PB1) | (1 << PB0); // MOSI, SCK, CE, CSN as outputs
    DDRB &= ~(1 << PB4); // MISO as input
    SPCR = (1 << SPE) | (1 << MSTR) | (1 << SPR0); // Enable SPI, Master, fosc/16
    CSN_HIGH();
    CE_LOW();
}

*** CSN_LOW();                 // Start SPI command
spi_transfer(command);     // Send command byte
spi_transfer(data);        // Send or receive data
CSN_HIGH();                // End SPI command ***

uint8_t spi_transfer(uint8_t data) {
    SPDR = data;
    while (!(SPSR & (1 << SPIF)));
    return SPDR;
}

// -----------------------------------------
// NRF24L01 COMMANDS
// -----------------------------------------
#define NRF_W_REGISTER 0x20
#define NRF_FLUSH_TX   0xE1
#define NRF_WRITE_TX   0xA0

void nrf_write_register(uint8_t reg, uint8_t value) {
    CSN_LOW();
    spi_transfer(NRF_W_REGISTER | (reg & 0x1F));
    spi_transfer(value);
    CSN_HIGH();
}

void nrf_write_payload(uint8_t *data, uint8_t len) {
    CSN_LOW();
    spi_transfer(NRF_WRITE_TX);
    for (uint8_t i = 0; i < len; i++)
        spi_transfer(data[i]);
    CSN_HIGH();
}

void nrf_flush_tx(void) {
    CSN_LOW();
    spi_transfer(NRF_FLUSH_TX);
    CSN_HIGH();
}

// -----------------------------------------
// NRF24L01 INITIALIZATION
// -----------------------------------------
void nrf_init(void) {
    _delay_ms(100);
    nrf_write_register(0x00, 0x0A); // CONFIG: PWR_UP=1, PRIM_TX=0
    nrf_write_register(0x01, 0x3F); // EN_AA
    nrf_write_register(0x02, 0x01); // EN_RXADDR pipe0
    nrf_write_register(0x03, 0x03); // SETUP_AW (5 bytes)
    nrf_write_register(0x04, 0x04); // SETUP_RETR
    nrf_write_register(0x05, 0x02); // RF_CH
    nrf_write_register(0x06, 0x0F); // RF_SETUP
    nrf_flush_tx();
}

// -----------------------------------------
// JOYSTICK STRUCT
// -----------------------------------------
typedef struct {
    int16_t x;
    int16_t y;
    uint8_t button;
} JoystickPacket;

typedef struct {
    JoystickPacket left;
    JoystickPacket right;
} DualJoystickPacket;

// -----------------------------------------
// MAIN
// -----------------------------------------
int __main__(void) {
    uart_init();
    adc_init();
    spi_init();
    nrf_init();

    DDRD &= ~((1 << PD2) | (1 << PD5)); // Buttons as input
    PORTD |= (1 << PD2) | (1 << PD5);   // Enable pull-ups

    uint16_t x_centerLeft = adc_read(0);
    uint16_t y_centerLeft = adc_read(1);
    uint16_t x_centerRight = adc_read(3);
    uint16_t y_centerRight = adc_read(2);

    uart_print("NRF24 TX Ready\r\n");

    while (1) {
        uint16_t xLeft = adc_read(0);
        uint16_t yLeft = adc_read(1);
        uint8_t bLeft = !(PIND & (1 << PD2));

        uint16_t xRight = adc_read(3);
        uint16_t yRight = adc_read(2);
        uint8_t bRight = !(PIND & (1 << PD5));

        DualJoystickPacket packet;
        packet.left.x = xLeft - x_centerLeft;
        packet.left.y = yLeft - y_centerLeft;
        packet.left.button = bLeft;
        packet.right.x = xRight - x_centerRight;
        packet.right.y = yRight - y_centerRight;
        packet.right.button = bRight;

        CE_LOW();
        nrf_write_payload((uint8_t*)&packet, sizeof(packet));
        CE_HIGH();
        _delay_ms(1);
        CE_LOW();

        // Debug output
        uart_print("L(");
        uart_print_int(packet.left.x);
        uart_print(",");
        uart_print_int(packet.left.y);
        uart_print(",");
        uart_print_int(packet.left.button);
        uart_print("), R(");
        uart_print_int(packet.right.x);
        uart_print(",");
        uart_print_int(packet.right.y);
        uart_print(",");
        uart_print_int(packet.right.button);
        uart_print(")\r\n");

        _delay_ms(200);
    }
}


// #include <SPI.h>
// #include <RF24.h>

// RF24 radio(9, 8);  // CE, CSN pins
// const byte address[6] = "00001";

// const int xPinLeft = A0;
// const int yPinLeft = A1;
// const int buttonPinLeft = 2; 

// const int xPinRight = A2;
// const int yPinRight = A3; 
// const int buttonPinRight = 5;

// // const int ledPin = 4;

// int16_t x_minLeft = 1023, x_maxLeft = 0, x_centerLeft = 512;
// int16_t y_minLeft = 1023, y_maxLeft = 0, y_centerLeft = 512;

// int16_t x_minRight = 1023, x_maxRight = 0, x_centerRight = 512;
// int16_t y_minRight = 1023, y_maxRight = 0, y_centerRight = 512;

// int16_t normalize(int16_t raw, int16_t min_value, int16_t max_value){
//   return map(raw, min_value, max_value, 512, -512);
// }

// typedef struct{
//   int16_t x;
//   int16_t y;
//   uint8_t button;
// } JoystickPacket;

// typedef struct {
//     JoystickPacket left;
//     JoystickPacket right;
// } DualJoystickPacket;

// // Function to print an int value with fixed width (spaces for padding)
// void printPadded(int value, int width) {
//   int len = String(value).length(); // get number of digits
//   for (int i = len; i < width; i++) {
//     Serial.print(' '); // print spaces for padding
//   }
//   Serial.print(value);
// }

// // Function to print both joysticks with input parameters
// void printJoysticks(int16_t xL, int16_t yL, uint8_t bL,
//                     int16_t xR, int16_t yR, uint8_t bR) {
//   Serial.print("left = (");
//   printPadded(xL, 4);
//   Serial.print(", ");
//   printPadded(yL, 4);
//   Serial.print(", ");
//   printPadded(bL, 4);
//   Serial.print("), right = (");
//   printPadded(xR, 4);
//   Serial.print(", ");
//   printPadded(yR, 4);
//   Serial.print(", ");
//   printPadded(bR, 4);
//   Serial.println(")");
// }

// int16_t read_analog_average(const int pin, uint8_t num_samples=10){
//   int32_t sum = 0;
//   for(int i=0; i<num_samples; i++) sum += analogRead(pin);
//   return sum / num_samples;
// }

// void setup() {
//   Serial.begin(9600);
//   pinMode(buttonPinLeft, INPUT_PULLUP);
//   pinMode(buttonPinRight, INPUT_PULLUP);
//   // pinMode(ledPin, OUTPUT);

//   x_centerLeft = read_analog_average(xPinLeft, 10);
//   y_centerLeft = read_analog_average(yPinLeft, 10);
//   x_centerRight = read_analog_average(xPinRight, 10);
//   y_centerRight = read_analog_average(yPinRight, 10);

//   radio.begin();
//   radio.openWritingPipe(address);
//   radio.setPALevel(RF24_PA_MIN);
//   radio.stopListening();
// }

// void loop() {
//   uint16_t xLeft = analogRead(xPinLeft);
//   uint16_t yLeft = analogRead(yPinLeft);
//   uint8_t buttonLeft = digitalRead(buttonPinLeft);

//   uint16_t xRight = analogRead(xPinRight);
//   uint16_t yRight = analogRead(yPinRight);
//   uint8_t buttonRight = digitalRead(buttonPinRight);

//   bool pressedLeft = (buttonLeft == LOW) ? true : false;
//   bool pressedRight = (buttonRight == LOW) ? true : false;

//   // int16_t x_norm = normalize(x, x_min, x_max);
//   // int16_t y_norm = normalize(y, y_min, y_max);

//   int16_t x_normLeft = xLeft - x_centerLeft;
//   int16_t y_normLeft = yLeft - y_centerLeft;

//   int16_t x_normRight = xRight - x_centerRight;
//   int16_t y_normRight = yRight - y_centerRight;

//   JoystickPacket packetLeft = {x_normLeft, y_normLeft, buttonLeft};
//   JoystickPacket packetRight = {x_normRight, y_normRight, buttonRight};
//   DualJoystickPacket joysticks = {packetLeft, packetRight};

//   bool success = radio.write(&joysticks, sizeof(joysticks)); 
//   printJoysticks(x_normLeft, y_normLeft, buttonLeft, x_normRight, y_normRight, buttonRight);
//   // digitalWrite(ledPin, (pressedLeft || pressedRight) ? HIGH : LOW);
// }
